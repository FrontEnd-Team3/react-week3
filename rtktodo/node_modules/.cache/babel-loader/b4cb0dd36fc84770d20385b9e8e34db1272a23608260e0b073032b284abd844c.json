{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from 'react';\nconst useInputs = initialValue => {\n  _s();\n  const [values, setValues] = useState(initialValue);\n  const onChnage = event => {\n    console.log(event.target.name);\n    setValues(prev => ({\n      ...prev,\n      [event.target.name]: event.target.value\n    }));\n  };\n\n  /*\n     * hint\n         콜스택, 힙\n         깊은복사 , 얕은복사\n         form Event\n     */\n\n  /*\n         state의 불변성\n         \n         state가 바뀌는 조건 ?\n         setValues(prev => prev[evet.target.name]: event.target.value)\n          state가 객체일 때, state는 deep equal을 통해 객체 내 키값의 데이터가 변화가 있는지 확인하고\n         상태를 업데이트 합니다. (\n          그러나 이러한 과정에서 새로운 객체를 선언하여 새로운 참조 메모리 주소값을 할당하면\n         리엑트는 deep equal을 하지 않고 메모리 주소 값이 달라졌으므로 상태를 업데이트 합니다.\n          따라서 데이터 객체일 때 깊은 복사를 통해 새로운 객체를 만들어주어 상태 업데이트 최적화를 진행\n          +\n          원본 데이터의 훼손이 일어나면 하나의 state는 다양한 컴포넌트에서 구독하고 있을 가능성이 있음\n         참조 데이터가 수정되면 현재 이 데이터를 참조하고 있는 컴포넌트에서 예외 상황이 발생할 수 있음\n         사이드 이펙트의 배제\n     */\n  return [values, onChnage, setValues];\n};\n_s(useInputs, \"HDCOOGj0LSEWzG+W461HfEYX8II=\");\nexport default useInputs;","map":{"version":3,"names":["useState","useInputs","initialValue","_s","values","setValues","onChnage","event","console","log","target","name","prev","value"],"sources":["/Users/zivivle/Downloads/rtktodo/src/hooks/use-inputs.js"],"sourcesContent":["import { useState } from 'react'\n\nconst useInputs = initialValue => {\n\tconst [values, setValues] = useState(initialValue)\n\n\tconst onChnage = event => {\n\t\tconsole.log(event.target.name)\n\t\tsetValues(prev => ({\n\t\t\t...prev,\n\t\t\t[event.target.name]: event.target.value,\n\t\t}))\n\t}\n\n\t/*\n    * hint\n        콜스택, 힙\n        깊은복사 , 얕은복사\n        form Event\n    */\n\n\t/*\n        state의 불변성\n        \n        state가 바뀌는 조건 ?\n        setValues(prev => prev[evet.target.name]: event.target.value)\n\n        state가 객체일 때, state는 deep equal을 통해 객체 내 키값의 데이터가 변화가 있는지 확인하고\n        상태를 업데이트 합니다. (\n\n        그러나 이러한 과정에서 새로운 객체를 선언하여 새로운 참조 메모리 주소값을 할당하면\n        리엑트는 deep equal을 하지 않고 메모리 주소 값이 달라졌으므로 상태를 업데이트 합니다.\n\n        따라서 데이터 객체일 때 깊은 복사를 통해 새로운 객체를 만들어주어 상태 업데이트 최적화를 진행\n\n        +\n\n        원본 데이터의 훼손이 일어나면 하나의 state는 다양한 컴포넌트에서 구독하고 있을 가능성이 있음\n        참조 데이터가 수정되면 현재 이 데이터를 참조하고 있는 컴포넌트에서 예외 상황이 발생할 수 있음\n        사이드 이펙트의 배제\n    */\n\treturn [values, onChnage, setValues]\n}\nexport default useInputs\n"],"mappings":";AAAA,SAASA,QAAQ,QAAQ,OAAO;AAEhC,MAAMC,SAAS,GAAGC,YAAY,IAAI;EAAAC,EAAA;EACjC,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGL,QAAQ,CAACE,YAAY,CAAC;EAElD,MAAMI,QAAQ,GAAGC,KAAK,IAAI;IACzBC,OAAO,CAACC,GAAG,CAACF,KAAK,CAACG,MAAM,CAACC,IAAI,CAAC;IAC9BN,SAAS,CAACO,IAAI,KAAK;MAClB,GAAGA,IAAI;MACP,CAACL,KAAK,CAACG,MAAM,CAACC,IAAI,GAAGJ,KAAK,CAACG,MAAM,CAACG;IACnC,CAAC,CAAC,CAAC;EACJ,CAAC;;EAED;AACD;AACA;AACA;AACA;AACA;;EAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAMC,OAAO,CAACT,MAAM,EAAEE,QAAQ,EAAED,SAAS,CAAC;AACrC,CAAC;AAAAF,EAAA,CAvCKF,SAAS;AAwCf,eAAeA,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}